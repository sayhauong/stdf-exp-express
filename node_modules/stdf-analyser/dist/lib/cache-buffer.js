"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BYTE_ORDER_BE = exports.BYTE_ORDER_LE = exports.BYTE_ORDER_AUTO = exports.ERR_OUT_OF_LIMIT = exports.ERR_OUT_OF_LENGTH = void 0;
const buffer_1 = require("buffer");
exports.ERR_OUT_OF_LENGTH = 'ERR_OUT_OF_LENGTH';
exports.ERR_OUT_OF_LIMIT = 'ERR_OUT_OF_LIMIT';
exports.BYTE_ORDER_AUTO = 0;
exports.BYTE_ORDER_LE = 1;
exports.BYTE_ORDER_BE = 2;
class CacheBuffer {
    constructor(opts) {
        this.byteOrder = exports.BYTE_ORDER_BE;
        this.pos = 0;
        this.end = 0;
        this.limitSize = 0;
        this.maxSize = opts ? (opts.bufferSize || 64 * 1024) : 64 * 1024;
        this.byteOrder = opts ? (opts.byteOrder || exports.BYTE_ORDER_BE) : exports.BYTE_ORDER_BE;
        this.buffer = buffer_1.Buffer.allocUnsafe(this.maxSize);
    }
    length() {
        return this.end - this.pos;
    }
    setByteOrder(order) {
        this.byteOrder = order;
    }
    setLimitSize(limit) {
        this.limitSize = limit;
    }
    resetLimitSize() {
        this.limitSize = 0;
    }
    shift(diff) {
        this.pos += diff;
        return this.pos;
    }
    push(buf, start = 0) {
        let len = buf.length - start;
        if (len > (this.buffer.length - this.end))
            len = this.buffer.length - this.end;
        buf.copy(this.buffer, this.end, start, start + len);
        this.end += len;
        return len;
    }
    pop(pos) {
        pos = pos || this.pos;
        // const buf: Buffer = Buffer.allocUnsafe(this.maxSize)
        // this.buffer.copy(buf, 0, pos, this.end)
        // this.buffer = buf
        this.buffer.copy(this.buffer, 0, pos, this.end);
        this.end = (this.end - pos);
        this.pos = 0;
        return pos;
    }
    check(len) {
        if ((this.end - this.pos) < len)
            throw new Error(exports.ERR_OUT_OF_LENGTH);
        if (this.limitSize > 0 && (this.pos + len) > this.limitSize)
            throw new Error(exports.ERR_OUT_OF_LIMIT);
    }
    readString(len, encoding) {
        this.check(len);
        const ret = this.buffer.toString(encoding || 'ascii', this.pos, this.pos + len);
        this.pos += len;
        return ret;
    }
    readInt8() {
        this.check(1);
        const ret = this.buffer.readInt8(this.pos);
        this.pos += 1;
        return ret;
    }
    readUInt8() {
        this.check(1);
        const ret = this.buffer.readUInt8(this.pos);
        this.pos += 1;
        return ret;
    }
    readInt16() {
        this.check(2);
        const ret = this.byteOrder === exports.BYTE_ORDER_BE ? this.buffer.readInt16BE(this.pos) : this.buffer.readInt16LE(this.pos);
        this.pos += 2;
        return ret;
    }
    readUInt16() {
        this.check(2);
        const ret = this.byteOrder === exports.BYTE_ORDER_BE ? this.buffer.readUInt16BE(this.pos) : this.buffer.readUInt16LE(this.pos);
        this.pos += 2;
        return ret;
    }
    readInt32() {
        this.check(4);
        const ret = this.byteOrder === exports.BYTE_ORDER_BE ? this.buffer.readInt32BE(this.pos) : this.buffer.readInt32LE(this.pos);
        this.pos += 4;
        return ret;
    }
    readUInt32() {
        this.check(4);
        const ret = this.byteOrder === exports.BYTE_ORDER_BE ? this.buffer.readUInt32BE(this.pos) : this.buffer.readUInt32LE(this.pos);
        this.pos += 4;
        return ret;
    }
    readDate() {
        this.check(4);
        const ret = this.byteOrder === exports.BYTE_ORDER_BE ? this.buffer.readUInt32BE(this.pos) : this.buffer.readUInt32LE(this.pos);
        this.pos += 4;
        return new Date(ret * 1000);
    }
    readFloat() {
        this.check(4);
        const ret = this.byteOrder === exports.BYTE_ORDER_BE ? this.buffer.readFloatBE(this.pos) : this.buffer.readFloatLE(this.pos);
        this.pos += 4;
        return ret;
    }
    readDouble() {
        this.check(8);
        const ret = this.byteOrder === exports.BYTE_ORDER_BE ? this.buffer.readDoubleBE(this.pos) : this.buffer.readDoubleLE(this.pos);
        this.pos += 8;
        return ret;
    }
    readBuffer(len) {
        this.check(len);
        const ret = buffer_1.Buffer.allocUnsafe(len);
        this.buffer.copy(ret, 0, this.pos, this.pos + len);
        this.pos += len;
        return ret;
    }
}
exports.default = CacheBuffer;
